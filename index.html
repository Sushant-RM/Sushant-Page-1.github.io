<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Concepts</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
            color: #333;
        }

        header {
            background-color: #4CAF50;
            color: white;
            text-align: center;
            padding: 1em;
        }

        header h1 {
            margin: 0;
        }

        section {
            margin: 20px;
        }

        h2 {
            color: #4CAF50;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 5px;
        }

        h3 {
            color: #333;
            margin-top: 15px;
        }

        ul {
            list-style-type: none;
            padding: 0;
        }

        li {
            margin: 5px 0;
        }

        .example {
            background-color: #e1f5e1;
            padding: 10px;
            margin: 10px 0;
            border-left: 4px solid #4CAF50;
        }

        .note {
            background-color: #fff3e0;
            border: 1px solid #fbc02d;
            padding: 10px;
            margin: 10px 0;
        }

        footer {
            background-color: #4CAF50;
            color: white;
            text-align: center;
            padding: 1em;
            position: fixed;
            width: 100%;
            bottom: 0;
        }

        .code {
            font-family: "Courier New", Courier, monospace;
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <header>
        <h1>Algorithm Concepts</h1>
    </header>

    <section id="space-time-efficiency">
    <h2>Space and Time Efficiency & Order of Growth</h2>
    <h3>Space Efficiency</h3>
    <p>Space efficiency refers to how much memory an algorithm uses. Imagine you're packing for a trip:</p>
    <ul>
        <li>Efficient Packing: You only take essentials, so your luggage is light.</li>
        <li>Inefficient Packing: You pack everything, making it hard to carry.</li>
    </ul>
    
    <h3>Time Efficiency</h3>
    <p>Time efficiency refers to how fast an algorithm completes its task. Think of it like a race:</p>
    <ul>
        <li>Efficient Algorithm: A fast runner finishing quickly.</li>
        <li>Inefficient Algorithm: A slow runner, especially with more work (bigger input).</li>
    </ul>
    
    <h3>Order of Growth</h3>
    <p>Order of growth measures how an algorithm's time or memory usage changes as input size increases:</p>
    <ul>
        <li>O(1): Constant time. E.g., Accessing the first item in a list.</li>
        <li>O(n): Linear time. E.g., Searching a book by checking each one.</li>
        <li>O(n²): Quadratic time. E.g., Nested operations like comparing every student.</li>
        <li>O(log n): Logarithmic time. E.g., Binary search in a dictionary.</li>
        <li>O(2ⁿ): Exponential time. E.g., Solving a puzzle doubling in possibilities.</li>
    </ul>
    <h2>Takeaways from Design Principles</h2>
    
    <h3>1. Divide and Conquer</h3>
    <p>Divide a big problem into smaller parts, solve each, and combine results.</p>
    <p>Example: Merge Sort divides and merges sorted lists.</p>
    
    <h3>2. Greedy Strategy</h3>
    <p>Make the best possible decision at each step, assuming it leads to the optimal solution.</p>
    <p>Example: Dijkstra’s Algorithm finds shortest paths by choosing the nearest node.</p>
    
    <h3>3. Dynamic Programming</h3>
    <p>Save results of smaller problems to reuse them and avoid recalculating.</p>
    <p>Example: Fibonacci Sequence uses stored results for efficiency.</p>
    
    <h3>4. Backtracking</h3>
    <p>Explore all solutions, backtracking if one path fails, to try others.</p>
    <p>Example: N-Queens Problem places queens on a chessboard without conflict.</p>
    <h2>Hierarchical Data and Tree Data Structures</h2>
    
    <h3>1. Hierarchical Data</h3>
    <p>Hierarchical data is organized in a tree-like structure with parent-child relationships.</p>
    <ul>
        <li>Family Trees: Representing family relationships.</li>
        <li>Company Hierarchies: Roles and departments.</li>
        <li>File Systems: Directories and files on a computer.</li>
    </ul>
    
    <h3>2. Tree Structures</h3>
    <p>Trees are hierarchical data structures with nodes. The top node is the root, and the bottom nodes are leaves. Types include:</p>
    <ul>
        <li><b>Binary Search Tree (BST)</b>: Left child < smaller value; Right child > larger value.</li>
        <li><b>AVL Tree</b>: Self-balancing BST ensuring height balance.</li>
        <li><b>Red-Black Tree</b>: A BST with red/black nodes to maintain balance.</li>
        <li><b>Heap</b>: Complete binary tree with Max-Heap (Parent > children) or Min-Heap (Parent < children).</li>
        <li><b>Trie</b>: A prefix tree for string storage.</li>
    </ul>
    <h2>Array Query Algorithms</h2>
    <p>Array query algorithms focus on efficiently answering specific questions or finding elements within an array.</p>
    <ul>
        <li>Binary Search: Efficient search on sorted arrays.</li>
        <li>Prefix Sum: Pre-computing sums to answer range queries quickly.</li>
        <li>Sliding Window: Efficiently computing results over a moving window in an array.</li>
    </ul>
    <h2>Tree vs. Graphs and Their Traversals</h2>
    
    <h3>Tree</h3>
    <p>A connected, acyclic graph with a unique path between any two nodes. Traversals include pre-order, in-order, and post-order.</p>
    
    <h3>Graph</h3>
    <p>A collection of vertices connected by edges, which may have cycles. Graph traversal methods include:</p>
    <ul>
        <li>BFS (Breadth-First Search): Explores nodes level by level.</li>
        <li>DFS (Depth-First Search): Explores nodes deeply before backtracking.</li>
    </ul>
    
    <h3>Applications:</h3>
    <ul>
        <li>Trees: Used in decision-making, file systems, and databases (e.g., B-trees for indexing).</li>
        <li>Graphs: Employed in network analysis, social networks, and route optimization.</li>
    </ul>
    <h2>Sorting and Searching Algorithms</h2>
    
    <h3>Sorting Algorithms</h3>
    <ul>
        <li>Bubble Sort: Repeatedly swaps adjacent elements if they’re in the wrong order.</li>
        <li>Insertion Sort: Inserts elements into their correct position.</li>
        <li>Merge Sort: Divides the array and merges subarrays.</li>
        <li>Quick Sort: Partitions the array and recursively sorts subarrays.</li>
        <li>Heap Sort: Builds a heap and extracts sorted elements.</li>
    </ul>
    
    <h3>Searching Algorithms</h3>
    <ul>
        <li>Linear Search: Checks each element sequentially.</li>
        <li>Binary Search: Efficiently finds an element in a sorted array by halving the search range.</li>
    </ul>
    <h2>Graph Algorithms</h2>
    <p>Graph algorithms deal with problems involving graphs like finding shortest paths, spanning trees, and connectivity.</p>
    <ul>
        <li>Dijkstra's Algorithm: Finds the shortest path from a source node to all other nodes.</li>
        <li>Bellman-Ford Algorithm: Finds shortest paths even with negative weights.</li>
        <li>Floyd-Warshall Algorithm: Calculates shortest paths between all pairs of nodes.</li>
        <li>Prim's Algorithm: Finds the Minimum Spanning Tree (MST) of a graph.</li>
    </ul>
    <h2>Importance of Graph Algorithms</h2>
    <p>Graph algorithms are essential in solving real-world problems such as:</p>
    <ul>
        <li><b>Spanning Trees</b>: Connects all vertices with the fewest edges, found using Kruskal’s and Prim’s algorithms.</li>
        <li><b>Shortest Paths</b>: Dijkstra’s and Bellman-Ford algorithms find the shortest paths, useful in GPS systems and network routing.</li>
        <li><b>Connectivity</b>: Identifying whether a graph is connected, or if there is a path between two nodes.</li>
    </ul>
</section>

    <footer>
        <p>&copy; 2024 Algorithm Concepts. All rights reserved.</p>
    </footer>
</body>
</html>
