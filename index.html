<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Concepts</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
            color: #333;
        }

        header {
            background-color: #4CAF50;
            color: white;
            text-align: center;
            padding: 1em;
        }

        header h1 {
            margin: 0;
        }

        section {
            margin: 20px;
        }

        h2 {
            color: #4CAF50;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 5px;
        }

        h3 {
            color: #333;
            margin-top: 15px;
        }

        ul {
            list-style-type: none;
            padding: 0;
        }

        li {
            margin: 5px 0;
        }

        .example {
            background-color: #e1f5e1;
            padding: 10px;
            margin: 10px 0;
            border-left: 4px solid #4CAF50;
        }

        .note {
            background-color: #fff3e0;
            border: 1px solid #fbc02d;
            padding: 10px;
            margin: 10px 0;
        }

        footer {
            background-color: #4CAF50;
            color: white;
            text-align: center;
            padding: 1em;
            position: fixed;
            width: 100%;
            bottom: 0;
        }

        .code {
            font-family: "Courier New", Courier, monospace;
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <header>
        <h1>Algorithm Concepts</h1>
    </header>

    <section>
        <h2>Types of Problems in Nature</h2>

        <h3>üìñ Iteration</h3>
        <p>Iteration means repeating a set of instructions until a condition is met.</p>
        <div class="example">
            <strong>Examples:</strong>
            <ul>
                <li>Finding the Sum of Elements: Add numbers like [2, 4, 6, 8], which gives 20.</li>
                <li>Sorting: Algorithms like Bubble Sort repeatedly swap out-of-order elements.</li>
            </ul>
        </div>

        <h3>üìÑ Recursion</h3>
        <p>Recursion is when a function calls itself to solve smaller parts of the problem.</p>
        <div class="example">
            <strong>Examples:</strong>
            <ul>
                <li>Factorial Calculation: 5! = 5 √ó 4!, eventually 120.</li>
                <li>Tree Traversals: Visit nodes in hierarchical data systematically.</li>
            </ul>
        </div>

        <h3>üîé Backtracking</h3>
        <p>Backtracking explores solutions but backtracks when hitting dead ends.</p>
        <div class="example">
            <strong>Examples:</strong>
            <ul>
                <li>Sudoku: Fill in numbers and retry upon conflicts.</li>
                <li>N-Queens: Try placing queens on a chessboard until valid.</li>
            </ul>
        </div>

        <div class="note">
            <strong>Quick Tip:</strong> Learn algorithms interactively on platforms like LeetCode or HackerRank!
        </div>

        <h2>Space and Time Efficiency & Order of Growth</h2>
        <h3>1. Space Efficiency</h3>
        <p>Space efficiency refers to how much memory an algorithm uses.</p>
        <div class="example">
            <strong>Efficient Packing:</strong> You only take essentials, so your luggage is light.<br>
            <strong>Inefficient Packing:</strong> You pack everything, making it hard to carry.
        </div>

        <h3>2. Time Efficiency</h3>
        <p>Time efficiency refers to how fast an algorithm completes its task.</p>
        <div class="example">
            <strong>Efficient Algorithm:</strong> A fast runner finishing quickly.<br>
            <strong>Inefficient Algorithm:</strong> A slow runner, especially with more work (bigger input).
        </div>

        <h3>3. Order of Growth</h3>
        <p>Order of growth measures how an algorithm's time or memory usage changes as input size increases:</p>
        <ul>
            <li><strong>O(1)</strong>: Constant time. E.g., Accessing the first item in a list.</li>
            <li><strong>O(n)</strong>: Linear time. E.g., Searching a book by checking each one.</li>
            <li><strong>O(n¬≤)</strong>: Quadratic time. E.g., Nested operations like comparing every student.</li>
            <li><strong>O(log n)</strong>: Logarithmic time. E.g., Binary search in a dictionary.</li>
            <li><strong>O(2‚Åø)</strong>: Exponential time. E.g., Solving a puzzle doubling in possibilities.</li>
        </ul>

        <h2>Takeaways from Design Principles</h2>
        <h3>1. Divide and Conquer</h3>
        <p>Divide a big problem into smaller parts, solve each, and combine results.</p>
        <div class="example">
            <strong>Example:</strong> Merge Sort divides and merges sorted lists.
        </div>

        <h3>2. Greedy Strategy</h3>
        <p>Make the best possible decision at each step, assuming it leads to the optimal solution.</p>
        <div class="example">
            <strong>Example:</strong> Dijkstra‚Äôs Algorithm finds shortest paths by choosing the nearest node.
        </div>

        <h3>3. Dynamic Programming</h3>
        <p>Save results of smaller problems to reuse them and avoid recalculating.</p>
        <div class="example">
            <strong>Example:</strong> Fibonacci Sequence uses stored results for efficiency.
        </div>

        <h3>4. Backtracking</h3>
        <p>Explore all solutions, backtracking if one path fails, to try others.</p>
        <div class="example">
            <strong>Example:</strong> N-Queens Problem places queens on a chessboard without conflict.
        </div>

        <h2>Hierarchical Data and Tree Data Structures</h2>
        <h3>1. Hierarchical Data</h3>
        <p>Hierarchical data is organized in a tree-like structure with parent-child relationships.</p>
        <div class="example">
            <strong>Examples:</strong>
            <ul>
                <li>Family Trees: Representing family relationships.</li>
                <li>Company Hierarchies: Roles and departments.</li>
                <li>File Systems: Directories and files on a computer.</li>
            </ul>
        </div>

        <h3>2. Tree Structures</h3>
        <p>Trees are hierarchical data structures with nodes. Types include:</p>
        <ul>
            <li><strong>Binary Search Tree (BST)</strong></li>
            <pre class="code">
                50
               /  \
             30    70
            /  \   /  \
           20  40 60   80
            </pre>
            <li><strong>AVL Tree</strong>: Self-balancing BST.</li>
            <li><strong>Red-Black Tree</strong>: A balanced BST with red/black nodes.</li>
            <li><strong>Heap</strong>: A complete binary tree with Max-Heap and Min-Heap variants.</li>
            <li><strong>Trie</strong>: A prefix tree for storing strings.</li>
        </ul>

        <h2>Sorting and Searching Algorithms</h2>
        <h3>1. Sorting Algorithms</h3>
        <ul>
            <li>Bubble Sort: Swaps adjacent elements repeatedly.</li>
            <li>Insertion Sort: Inserts elements in their correct position.</li>
            <li>Merge Sort: Divides and merges sorted subarrays.</li>
            <li>Quick Sort: Partitions and sorts recursively.</li>
            <li>Heap Sort: Uses heaps to sort efficiently.</li>
        </ul>

        <h3>2. Searching Algorithms</h3>
        <ul>
            <li>Linear Search: Checks each element sequentially.</li>
            <li>Binary Search: Efficient search on sorted arrays by halving the range.</li>
        </ul>

        <h2>Graphs and Their Applications</h2>
        <h3>1. Graph Basics</h3>
        <p>A graph consists of nodes (vertices) and edges (connections). Types of graphs include:</p>
        <ul>
            <li><strong>Undirected Graph:</strong> Edges have no direction.</li>
            <li><strong>Directed Graph:</strong> Edges have direction (arrows).</li>
            <li><strong>Weighted Graph:</strong> Edges have weights or costs.</li>
        </ul>

        <h3>2. Representations</h3>
        <ul>
            <li><strong>Adjacency Matrix:</strong> A 2D array where matrix[i][j] is 1 if there's an edge between nodes i and j.</li>
            <li><strong>Adjacency List:</strong> Each node points to a list of connected nodes.</li>
        </ul>

        <h3>3. Applications</h3>
        <ul>
            <li>Social Networks: Representing friendships or follows.</li>
            <li>Navigation: Shortest paths on maps (e.g., GPS).</li>
            <li>Recommendation Systems: Connections between users and products.</li>
        </ul>
    </section>

    <footer>
        <p>&copy; 2024 Algorithm Concepts. All rights reserved.</p>
    </footer>
</body>
</html>
