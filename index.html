<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Concepts</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2 {
            color: #333;
        }
        h2 {
            margin-top: 30px;
        }
        p {
            line-height: 1.6;
        }
        ul {
            margin: 10px 0;
        }
        code {
            background-color: #f4f4f4;
            padding: 2px 4px;
            border-radius: 4px;
        }
        .example {
            background-color: #e8f4f8;
            padding: 10px;
            margin: 10px 0;
            border-left: 5px solid #007BFF;
        }
        .section {
            margin-bottom: 40px;
        }
    </style>
</head>
<body>

    <h1>Algorithm Concepts</h1>

    <div class="section">
        <h2>1. Types of Problems in Nature (Iteration, Recursion, Backtracking)</h2>
        <p><strong>Iteration</strong>: Repeating a set of instructions until a condition is met. It's used for processing collections multiple times.</p>
        <div class="example">
            <ul>
                <li><strong>Finding the sum of elements in an array</strong>: Loop through the array and add up all the numbers.</li>
                <li><strong>Sorting an array</strong>: Algorithms like Bubble Sort use iteration to arrange elements.</li>
            </ul>
        </div>

        <p><strong>Recursion</strong>: A function calls itself to solve smaller parts of a problem.</p>
        <div class="example">
            <ul>
                <li><strong>Factorial calculation</strong>: Multiply a number recursively by smaller numbers down to 1.</li>
                <li><strong>Tree Traversals</strong>: Using recursion to visit nodes in pre-order, in-order, or post-order.</li>
            </ul>
        </div>

        <p><strong>Backtracking</strong>: Explores all solutions by trying each option and backtracking when necessary.</p>
        <div class="example">
            <ul>
                <li><strong>Solving Sudoku</strong>: Try values and backtrack if there's a conflict.</li>
                <li><strong>N-Queens problem</strong>: Try placing queens so they don't threaten each other and backtrack if a solution doesn't work.</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>2. Space and Time Efficiency & Order of Growth</h2>
        <p><strong>Space Efficiency</strong>: Refers to how much memory an algorithm uses.</p>
        <p><strong>Time Efficiency</strong>: Refers to how fast an algorithm runs, often described by time complexity.</p>
        <p><strong>Order of Growth</strong>: Describes how the time or space complexity increases with input size:</p>
        <ul>
            <li><code>O(1)</code>: Constant time</li>
            <li><code>O(n)</code>: Linear time</li>
            <li><code>O(n²)</code>: Quadratic time</li>
            <li><code>O(log n)</code>: Logarithmic time</li>
            <li><code>O(2^n)</code>: Exponential time</li>
        </ul>
        <p><strong>Class of Problems</strong>:</p>
        <ul>
            <li><strong>Polynomial Time Problems</strong>: Solvable efficiently as input size grows.</li>
            <li><strong>NP-Hard/NP-Complete</strong>: Problems that become impractical for large inputs.</li>
        </ul>
    </div>

    <div class="section">
        <h2>3. Takeaways from Design Principles</h2>
        <ul>
            <li><strong>Divide and Conquer</strong>: Break problems into smaller sub-problems (e.g., Merge Sort).</li>
            <li><strong>Greedy Strategy</strong>: Make the best choice at each step (e.g., Dijkstra’s algorithm).</li>
            <li><strong>Dynamic Programming</strong>: Solve overlapping subproblems (e.g., Fibonacci sequence).</li>
            <li><strong>Backtracking</strong>: Explore all solutions and backtrack when necessary (e.g., N-Queens problem).</li>
        </ul>
    </div>

    <div class="section">
        <h2>4. Hierarchical Data and Tree Data Structures</h2>
        <p><strong>Hierarchical Data</strong>: Data structured in a tree-like fashion, with parent-child relationships. Examples include family trees and file systems.</p>
        <p><strong>Tree Structures</strong>:</p>
        <ul>
            <li><strong>BST</strong>: A tree where each node’s left child is smaller and the right child is larger.</li>
            <li><strong>AVL Tree</strong>: A self-balancing BST.</li>
            <li><strong>Red-Black Tree</strong>: A balanced tree using color properties.</li>
            <li><strong>Heap</strong>: A complete binary tree, used in priority queues.</li>
            <li><strong>Trie</strong>: A tree for storing strings, used in autocomplete systems.</li>
        </ul>
    </div>

    <div class="section">
        <h2>5. Array Query Algorithms</h2>
        <p>These algorithms allow efficient answers to range queries in arrays.</p>
        <div class="example">
            <ul>
                <li><strong>Prefix Sum Arrays</strong>: Quickly calculate the sum of elements in a range.</li>
                <li><strong>Segment Trees</strong>: Handle range queries and updates efficiently.</li>
                <li><strong>Sparse Tables</strong>: Optimized for range minimum queries.</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>6. Tree vs. Graphs and Their Traversals</h2>
        <p><strong>Tree</strong>: A connected, acyclic graph. Traversal types include pre-order, in-order, and post-order.</p>
        <p><strong>Graph</strong>: A collection of vertices connected by edges, possibly with cycles. Traversals include BFS (level-wise) and DFS (deep-first).</p>
    </div>

    <div class="section">
        <h2>7. Sorting and Searching Algorithms</h2>
        <p><strong>Sorting Algorithms</strong>:</p>
        <ul>
            <li><strong>Bubble Sort</strong>: Repeatedly swaps adjacent elements if needed.</li>
            <li><strong>Insertion Sort</strong>: Inserts elements into the sorted part of the array.</li>
            <li><strong>Merge Sort</strong>: Divides and merges sorted subarrays.</li>
            <li><strong>Quick Sort</strong>: Partitions and recursively sorts subarrays.</li>
            <li><strong>Heap Sort</strong>: Builds a heap and sorts by extracting elements.</li>
        </ul>
        <p><strong>Searching Algorithms</strong>:</p>
        <ul>
            <li><strong>Linear Search</strong>: Checks each element sequentially.</li>
            <li><strong>Binary Search</strong>: Efficient for sorted arrays by halving the search range.</li>
        </ul>
    </div>

    <div class="section">
        <h2>8. Importance of Graph Algorithms (Spanning Trees and Shortest Paths)</h2>
        <ul>
            <li><strong>Spanning Trees</strong>: Connect all vertices with the least edges, using Kruskal’s and Prim’s algorithms.</li>
            <li><strong>Shortest Paths</strong>: Dijkstra’s and Bellman-Ford find the shortest path between nodes.</li>
        </ul>
    </div>

    <div class="section">
        <h2>9. Algorithm Design Techniques</h2>
        <ul>
            <li><strong>Dijkstra’s Algorithm</strong>: Finds the shortest path in a weighted graph.</li>
            <li><strong>Floyd’s Algorithm</strong>: Calculates all-pairs shortest paths.</li>
            <li><strong>Kruskal’s Algorithm</strong>: Finds the Minimum Spanning Tree (MST).</li>
            <li><strong>Warshall’s Algorithm</strong>: Computes transitive closure.</li>
            <li><strong>Prim’s Algorithm</strong>: Finds the MST by growing a tree.</li>
        </ul>
    </div>

</body>
</html>
